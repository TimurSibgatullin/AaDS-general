import java.util.*;

// задаём граф номером вершины и списком вершин, в которые можно из неё перейти
Map<Integer, List<Integer>> graph = new HashMap<>();

public Set<Integer> BFS(Integer startVertice) {
    // создаём структуру для хранения посещённых (горящих) вершин,
    // можно было использовать список, но множество быстрее
    Set<Integer> visited = new HashSet<>();

    // создаём структуру для хранения вершин, которые только что загорелись (так называемый фронт пожара)
    // нам нужно иметь возможность обрабатывать вершины в порядке их появления, поэтому используем очередь
    Queue<Integer> burning = new LinkedList<>();

    // добавляем в очередь первую вершину с которой и начнём обход (поджигаем вершину)
    burning.add(startVertice);

    // добавляем эту вершину в список посещённых (мы её подожгли и она горит)
    visited.add(startVertice);

    // идём пока очередь только что подожжённых вершин не пуста
    while (!burning.isEmpty()) {

        // достаём первую вершину и закидываем её в current
        // (после неё загорятся другие вершины, теперь она не крайняя)
        Integer current = burning.poll();

        // проходимся по всем соседним вершинам, на которые должен перекинуться огонь
        for (Integer descendant : graph.getOrDefault(current, List.of())) {

            // если этой вершины нет в множестве посещённых (горящее поджечь нельзя), то
            if (!visited.contains(descendant)) {
                // добавляем её в очередь горящих вершин (от которых будут поджигаться следующие)
                burning.add(descendant);

                // не отходя от кассы добавляем её в множество посещённых
                visited.add(descendant);
            }
        }
    }
    // возвращаем множество посещённых вершин, это и есть результат работы алгоритма
    return visited;
}
